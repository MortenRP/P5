\section{Data preprocessing}
Here we discuss how to process the Beijing training set. The overall process is illustrated in \ref{fig:data-processing}.

\begin{figure}[h!]
  \centering
    \includegraphics[width=1\textwidth]{figures/data-processing.pdf}
    \caption{From raw gps data to database}
    \label{fig:data-processing}
\end{figure}

The gps dataset is converted into the GPX format which is subsequently map-matched to the road network of Beijing. The map-matched data is then converted into the model objects of the system, and are then stored in the respective tables of the database. Likewise, the map of the Beijing road network is converted to model objects and stored in the database. By doing so, we have a knowledge base of the road network of Beijing and data about vehicle movements in a unified format. \todo{maybe we should perform some data cleaning}

\subsection{Map generation}%\label{sec:mapgeneration}
To model the road network of Beijing we need to have the specific information about all the roads in the road network. This information is available several places, but most of these services are not free. We have chosen to work with OpenStreetMap which is an open source map service, where users collaborate to keep the city maps updated. There are some problems in using this kind of service, such as the possibility of wrong data, limited data, since that the map is updated by users, so it's is possible for at user to make erroneous updates\todo{læs? + mangler kilde?}. But because this service was the only free service that we could find, we see no other option than having in mind that these problems can occur. We have also found that the OpenStreetMap site cannot export large areas of a map, such as the whole city of Beijing. Therefore we have chosen to use one of its mirror sites, Geofabrik, which holds extracts\todo{Forstår ikke helt det?} of the whole world, segmented into countries and these are updated daily. This makes it possible for us to extract the whole map for China.

\subsubsection{Format \& Pre-processing}
\label{chap:FormatPre-processing}
The maps from Geofabrik comes in a compressed format called pbf. To extract the relevant data from this format we are using a tool called Osmosis, to query the file using several filters to be able to extract only the information relevant.

We are using two types of filters with Osmosis, the first is to limit the area that we want to extract, since the map we got is for all of China. The second filter is used to extract only roads from the restricted area. With this filter we have the possibility to specify which roads we want to have in the output. Because all paths are marked in OpenStreetMap as a way, we want to filter paths in order to remove side-walks, bicycle ways, and other ways that are not possible to use with a car.

The extracted data from the Osmosis query is then exported to a file which is structured in a way that resembles the XML format. There are two types left in the export, which are nodes and ways. Nodes represent road intersections and are also used to indicate points along a road if the road is curved. Both nodes and ways can include key-value pairs that contain information, i.e. if a way is one-way, if a intersection have a traffic light, ect\todo{igen, er etc godt nok at skrive?}.
Ways are almost similar structured, but they also contain a nd tag which contains a value the id of a node related to the way.\todo{Forstår ikke den sidste sætning her}

\begin{lstlisting}[style=XML, caption=Node representation]
<node id, version, timestamp, uid, user, changeset, longitude, latitude >
	<tag key, value />
</node>
\end{lstlisting}

\begin{lstlisting}[style=XML, caption=Way representation]
<Way id, version, timestamp, uid, user, changeset >
	<nd ref />
	<tag key, value />
</way>
\end{lstlisting}

We have illustrated the representation of nodes, ways, edges and segments in \figref{fig:waywithnodes}. The red nodes represent intersections, the green nodes are points along a way, edges are the black lines between every node, the way is the entire black line, and segments are represented by the blue lines between intersection nodes.

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.8\textwidth]{figures/way-w-nodes.png}
    \caption{A way with nodes}
    \label{fig:waywithnodes}
\end{figure}

\subsubsection{Generation}
An XML parser is used to extract the information from the Osmosis export that is needed to model the road network. When a node or way tag is read a equivalent data structure is created and stored.

\begin{lstlisting}[style=java, caption=Datastructure for a node]
Node{
	long id;
	double longitude;
	double latitude;
	Way[] connectedWays;
}
\end{lstlisting}

\begin{lstlisting}[style=java, caption=Datastructure for a way]
Way{
	long id;
	Node[] connectedNodes;
	int type;
}
\end{lstlisting}

We want to model the road network as a graph, but the relation between ways and nodes are not in this format when exported from Osmosis, so we have to work on the data structures generated from the parser.
Besides the original way and node data structures, we have chosen to create two other classes such that we are able to construct a graph, these are called edges and segments.

Edges are the links between every two nodes and a segment is the link between to intersection nodes. When generating these classes from ways and nodes, we have to check whether a way has a tag attached to it which describes if the way is one-way or not, because if it is we have to create edges and segments in both directions.

\begin{lstlisting}[style=java, caption=Datastructure for an edge]
Edge{
	long id;
	double length;
	long origin;
	long destination;
	long segment;
}
\end{lstlisting}

\begin{lstlisting}[style=java, caption=Datastructure for a segment]
Segment{
	long id;
	double length;
	long way;
	long origin;
	long destination;
}
\end{lstlisting}

The relation between edges and segments is that each edge of a segment contains a reference to the segment that it is a part of, the same is true from the relation between ways and segments.

\subsection{Data filtering}\label{sec:datafiltering}
% WHAT IS IT?
% WHY DO WE DO IT?
% HOW DO WE DO IT?
We perform a simple spatial and temporal filtering the GPS data, by filtering GPS samples from outside the physical city limits. The limits are given by a bounding box defined by the coordinates \todo{insert coordinates}. Cleaning the data before further processing is key, since not all of the data is accurate or even useful for reasoning about the traffic. We Even though of the data that is filtered is reliable enough, we delimit our focus on congestion in the city center, so we chose to look aside this data. Since most of the data is clustered in the city center anyway, we do not lose significant parts of the dataset by filtering these samples.

Furthermore, some GPS samples are of very bad quality. Some routes are (according to the GPS samples) at one moment driving through Bejing, and the next moment suddenly driving in Africa or Europe. This phenomenon could be caused by weak connection to the GPS satelites e.g. when driving through are tunnel. The inacuraries these corrupt samples introduce, are taken care of as well by filtering samples outside of the city limits. Fortunately, we do not lose all of the samples associated with the rest of the route involved - just the corrupted sample.

GPS samples that is shown to have completely unrealistic properties is also cleaned from the dataset. An example would be the speed driven between two samples relative to the change in distance between the sampling timestamps. If the speed required to move the physical distance in that time is unrealistic (say, well above what a car can actually drive), we filter these "bad" observations. Note that we actually postpone the filtering of these samples, as it is easier to take into account after map-matching of the GPS samples has been completed.

\subsection{Map matching}\label{sec:mapmatching}
Generally, GPS coordinates measured are often imprecise due to external factors, and do therefore not reflect the precise location of, in this case, a vehicle. Consequently, the samples of the traning set must be treated as approximations of GPS locations. This causes some problems in terms of how we should decide which road the vehicle was traveling on and what its speed was.

\begin{figure}
\includegraphics[scale=1]{figures/mapmatching.png}
\caption{GPS samples and the actual road driven on.}
\label{fig:mapmatching}
\end{figure}

The problem is illustrated in figure \ref{fig:mapmatching}. The orange-and-black colored GPS samples are imprecise in the sense that they are not mapped directly onto the blue road. The straightforward solution would just be to map the samples to the road closest to the collection of samples. However if the road network is dense, we can have multiple candidates for roads, since the distance from the samples to the two roads might be equal.

Consequently, we must perform the process of \emph{map-matching} the dataset of GPS samples to the most likely roads that vehicles was traveling on. Several algorithms and implementations exist that perform this task, including TrackMatching, GraphHopper and N-Gemma.\todo{Consider adding a source for each tool.}  Limited informal evaluations of these implementations showed that TrackMatching provided a more precise map-matching than GraphHopper, both of which work with GPX-formatted GPS samples. Unfortunately, the documentation for N-Gemma was incomplete, and as such, we decided to not investigate further the use of N-Gemma, since TrackMatching was an adequate solution to the map-matching problem, despite it being a webservice.

Alternatively, we considered implementing a map-matching algorithm ourselves, however given that the focus of the project is on constructing an intelligent routing agent; not an efficient map-matching algorithm, we decided that our time would be better spent elsewhere, and opted for utilising an existing implementation for map-matching.

\subsubsection{TrackMatching input and output}
We chose to use the GPX format for input and GeoJSON as the output of the map-matcher.\todo{why?} The output is represented as a tree structure in \figref{fig:geojson}. The \emph{links} element of each \emph{route} is an array of link objects.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	\node {(root)}
	[
		level distance=1cm,
		level 1/.style={sibling distance=2cm},
		level 2/.style={sibling distance=1.5cm}
	]
	child { node {diary}
		child { node {entries}
			child { node {$\text{route}_\text{1}$}
				child { node {$\text{links}_\text{1}$}
					edge from parent [->] node [left] {}
				}
				edge from parent [->] node [left] {}
			}
			child { node {...}
				child { node {...}
					edge from parent [->] node {}
				}
				edge from parent [->] node {}
			}
			child { node {$\text{route}_\text{n}$}
				child { node {$\text{links}_\text{n}$}
					edge from parent [->] node [right] {}
				}
				edge from parent [->] node [right] {}
			}
			edge from parent [->] node {}
		}
		edge from parent [->] node [left] {}
	}
	child { node (a) {options}
		edge from parent [->] node {}
	}
	child { node [right=0.5cm of a] {performanceIndicators}
		edge from parent [->] node [right] {}
	}
	;
	\end{tikzpicture}
	\caption{Structure of GeoJSON output.}
	\label{fig:geojson}
\end{figure}

A simple example of a link object can be seen in \coderef{lst:geojson:link}. The \textbf{err} (error) attribute describes how accurately the waypoints were matched to a way; the lower the error, the more likely that the correct way was picked. The \textbf{src} (source) and \textbf{dst} (destination) attributes correspond to nodes in the map on the same way, which is identified through the \textbf{id} attribute (i.e., nodes \#src and \#dst are on way \#id). The source node in the next link is the destination node in the previous link, except for the first link. The coordinates in the \textbf{geometry} attribute contains the longitudes and latitudes for each node that is passed through in the link. The \textbf{wpts} (waypoints) attribute contains the coordinates, id (within the link) and timestamp for each waypoint matched to the link. \todo{mangler noget her: hvorfor er det interessant? HVad bliver de forskellige dele brugt til?}

\begin{lstlisting}[style=java, caption=Content of a simple link object., label=lst:geojson:link]
{
  "err":398.43,
  "src":2639384604,
  "dst":2639384636,
  "id":258604821,
  "geometry":"{\"type\": \"LineString\", \"coordinates\": [[1.2997645E7, 4836996],[1.2997724E7, 4837050],[1.2997795E7, 4837084.5],[1.2997899E7, 4837123]]}",
  "wpts":[{
    "x":1.2997645E7,
    "y":4836996,
    "id":"0",
    "timestamp":"2008-02-02T15:10:20Z"
  },
  {
    "x":1.2998036E7,
    "y":4837174,
    "id":"1",
    "timestamp":"2008-02-02T15:10:25Z"
  }]
}
\end{lstlisting}
